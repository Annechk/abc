# Задание 3. Локальный поиск: 1-оптимизация TSP 
## Условие.
Улучшить заданный маршрут TSP, пробуя поменять пару рёбер (2-opt). 
## Алгоритм:
локальный поиск (2-opt). 
## Язык примера:
C++ 
```cpp
vector<int> twoOpt(vector<int> path, const vector<vector<int>>& dist) { 
bool improved = true; 
while (improved) { 
improved = false; 
for (int i = 1; i < path.size() - 2; i++) { 
for (int j = i + 1; j < path.size() - 1; j++) { 

// ДОПИСАТЬ: проверить, улучшает ли обмен (i,j) длину маршрута 
} 
} 
} 
21 
} 
return path; 
```
## Что дописать: 
расчёт разницы длин до/после обмена.


# Объяснение работы алгоритма:

## Шаг 1: Инициализация цикла улучшений

**Начало итеративного процесса**
```cpp
bool improved = true;
```
- Флаг `improved` отслеживает, было ли найдено улучшение на текущей итерации

## Шаг 2: Проверка всех возможных пар рёбер

**Перебор первой точки разрыва**
```cpp
for (int i = 1; i < path.size() - 2; i++) {
```
- Перебираем все возможные позиции `i` для первого разрыва маршрута
- Начинаем с 1 (после стартовой вершины), заканчиваем за 2 позиции до конца

**Перебор второй точки разрыва**
```cpp
for (int j = i + 1; j < path.size() - 1; j++) {
```
- Для каждого `i` перебираем все возможные позиции `j` для второго разрыва
- `j` всегда больше `i`, чтобы обеспечить корректный сегмент для переворота

## Шаг 3: Оценка улучшения маршрута

**Расчёт текущей длины двух рёбер**
```cpp
int current = dist[path[i-1]][path[i]] + dist[path[j]][path[j+1]];
```
- Вычисляем сумму длин рёбер, которые будут удалены: (i-1→i) и (j→j+1)

**Расчёт новой длины после обмена**
```cpp
int new_len = dist[path[i-1]][path[j]] + dist[path[i]][path[j+1]];
```
- Вычисляем сумму длин новых рёбер, которые появятся: (i-1→j) и (i→j+1)

## Шаг 4: Применение улучшения

**Проверка условия улучшения**
```cpp
if (new_len < current) {
```
- Если новая комбинация рёбер короче текущей, выполняем перестановку

**Переворот сегмента маршрута**
```cpp
swap(path[left], path[right]); 
```
- Переворачиваем сегмент пути между позициями `i` и `j`
- Это эквивалентно замене двух рёбер на два других с изменением направления сегмента

## Шаг 5: Продолжение поиска улучшений

**Установка флага улучшения**
```cpp
improved = true;
```
- После применения улучшения устанавливаем флаг для продолжения поиска
- Алгоритм будет повторять итерации, пока находятся улучшения

# Временная сложность:
- **В худшем случае:** O(n³) - три вложенных цикла (while × for × for)
- **На практике:** O(k×n²), где k - количество итераций до сходимости
- **Для каждой итерации:** O(n²) проверок пар рёбер

# Контрольный вопрос 3
# PTAS и FPTAS: различия

## PTAS (Polynomial-Time Approximation Scheme)
- **Время работы:** Полиномиально от размера входа n при фиксированном ε
- **Сложность:** O(n^f(ε)) где f(ε) - некоторая функция от точности
- **Пример:** O(n^(1/ε)) или O(n^(ε^(-2)))
- **Особенность:** При очень малых ε время работы становится непрактично большим

## FPTAS (Fully Polynomial-Time Approximation Scheme)
- **Время работы:** Полиномиально и от n, и от 1/ε
- **Сложность:** O((n/ε)^c) где c - константа
- **Пример:** O(n^2/ε) или O(n/ε^2)
- **Особенность:** Остается практичным даже при очень высоких требованиях к точности

## Ключевые различия
PTAS: время растет как n^f(ε)
FPTAS: время растет как poly(n, 1/ε)

**Главное отличие:** FPTAS масштабируется лучше при увеличении точности (уменьшении ε), тогда как PTAS при малых ε становится непрактичным из-за экспоненциального роста времени выполнения относительно 1/ε.
