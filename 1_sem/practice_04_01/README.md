# Вариант 6. Приближенный алгоритм для TSP (2-аппроксимация) 

## Задача: 
реализовать простой 2-аппроксимационный алгоритм для TSP: построить минимальное остовное дерево, удвоить ребра, найти эйлеров обход и исключить повторения. 

## Требования:
- Входные данные: граф с весами ребер (полный граф, метрическое пространство)
- Выход: приближенный маршрут и его стоимость 
- Вывести соотношение найденного решения к нижней оценке 

## Входные данные: 
Матрица расстояний между 5 городами (полная матрица 5x5) 


# Объяснение работы алгоритма:

## Шаг 1: Построение минимального остовного дерева (MST)

1. **Создание объекта графа**
   ```python
   g = Graph(n)
   ```
   - Создается объект класса Graph с указанием количества вершин
   - Инициализируется пустой список для хранения рёбер

2. **Добавление всех возможных рёбер**
   ```python
   for i in range(n):
       for j in range(i + 1, n):
           g.add_edge(i, j, dist_matrix[i][j])
   ```
   - Для каждой пары вершин (i, j) добавляется ребро с весом из матрицы расстояний
   - Используется только верхняя треугольная матрица для избежания дублирования

3. **Сортировка рёбер по весу**
   ```python
   self.graph = sorted(self.graph, key=lambda item: item[2])
   ```
   - Рёбра сортируются по третьему элементу (весу) в возрастающем порядке
   - Это ключевой шаг жадной стратегии алгоритма Крускала

4. **Инициализация структур Union-Find**
   ```python
   parent = []
   rank = []
   for node in range(self.V):
       parent.append(node)
       rank.append(0)
   ```
   - Создается массив parent для отслеживания принадлежности к множествам
   - Массив rank оптимизирует объединение множеств

5. **Построение MST**
   ```python
   while e < self.V - 1:
       u, v, w = self.graph[i]
       i += 1
       x = self.find(parent, u)
       y = self.find(parent, v)
       if x != y:
           e += 1
           result.append([u, v, w])
           self.union(parent, rank, x, y)
   ```
   - Последовательно обрабатываются отсортированные рёбра
   - Метод `find()` определяет принадлежность вершин к компонентам
   - Метод `union()` объединяет компоненты при добавлении безопасного ребра

## Шаг 2: Удвоение рёбер MST

### Выполненные действия:
1. **Создание мультиграфа**

   ```python
   adjacency = defaultdict(list)
   for u, v, w in mst:
       adjacency[u].append((v, w))
       adjacency[v].append((u, w))
   ```
   - Используется defaultdict для автоматического создания пустых списков
   - Каждое ребро MST добавляется в обоих направлениях
   - Создается структура списков смежности

## Шаг 3: Поиск эйлерова цикла

### Выполненные действия:
1. **Инициализация структур данных**
   ```python
   stack = [start]
   tour = []
   current_edges = {node: list(neighbors) for node, neighbors in adjacency.items()}
   ```
   - Стек хранит текущий путь обхода
   - Список tour накапливает окончательный маршрут
   - current_edges - копия списков смежности для модификации во время обхода

2. **Построение цикла**
   ```python
   while stack:
       v = stack[-1]
       if current_edges[v]:
           u, w = current_edges[v].pop()
           for i, (neighbor, weight) in enumerate(current_edges[u]):
               if neighbor == v:
                   current_edges[u].pop(i)
                   break
           stack.append(u)
       else:
           tour.append(stack.pop())
   ```
   - Алгоритм работает пока стек не пуст
   - `current_edges[v].pop()` извлекает и удаляет следующее ребро из вершины v
   - Удаление обратного ребра предотвращает повторное использование
   - Добавление в стек реализует углубление в граф
   - Извлечение из стека происходит при отсутствии исходящих рёбер

3. **Реверс результата**
   ```python
   return tour[::-1]
   ```
   - Так как вершины добавляются в обратном порядке, список переворачивается

## Шаг 4: Построение гамильтонова цикла

### Выполненные действия:
1. **Удаление повторяющихся вершин**
   ```python
   visited = set()
   hamiltonian_cycle = []
   for vertex in euler_circuit:
       if vertex not in visited:
           hamiltonian_cycle.append(vertex)
           visited.add(vertex)
   ```
   - Множество visited отслеживает уже включенные вершины
   - В цикл добавляется только первое вхождение каждой вершины

2. **Замыкание цикла**
   ```python
   hamiltonian_cycle.append(hamiltonian_cycle[0])
   ```
   - Добавляется начальная вершина для образования замкнутого цикла

## Шаг 5: Вычисление стоимости и анализ

### Выполненные действия:
1. **Расчет стоимости маршрута**
   ```python
   cost = 0
   for i in range(len(hamiltonian_cycle) - 1):
       cost += dist_matrix[hamiltonian_cycle[i]][hamiltonian_cycle[i + 1]]
   ```
   - Суммируются веса рёбер между последовательными вершинами цикла

2. **Вычисление нижней оценки**
   ```python
   mst_cost = sum(edge[2] for edge in mst)
   ```
   - Суммируются веса всех рёбер MST
   - Это дает теоретическую нижнюю границу стоимости оптимального решения

3. **Анализ качества**
   ```python
   approximation_ratio = cost / lower_bound
   ```
   - Вычисляется отношение стоимости найденного решения к нижней оценке
   - Проверяется выполнение условия approximation_ratio ≤ 2.0


# Временная сложность:
MST (Краскал): O(E log V) = O(V² log V) для полного графа
Эйлеров цикл: O(E) = O(V²)
Удаление повторов: O(V)
Общая сложность: O(V² log V)

# Контрольный вопрос 6

## Различия в операторах

| Аспект | Дробный рюкзак | 0-1 Рюкзак |
|--------|-----------------|------------|
| **Сортировка** | Обязательная `sort()` | Не требуется |
| **Условие выхода** | `break` при заполнении | Полный перебор всех предметов |
| **Обработка предмета** | Условное ветвление `if-else` | Вложенные циклы `for` |
| **Вычисление стоимости** | Прямое суммирование `+ value` | Рекуррентное соотношение `max()` |
| **Память** | O(1) дополнительной памяти | O(n·W) для DP-таблицы |

## Временная сложность операторов

**Дробный рюкзак:**
- `sort()`: O(n log n)
- Цикл `for`: O(n)
- **Итого:** O(n log n)

**0-1 Рюкзак:**
- Внешний цикл `for i in range(n)`: O(n)
- Внутренний цикл `for w in range(capacity)`: O(W)
- **Итого:** O(n·W)

