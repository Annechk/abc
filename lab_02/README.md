## Лабораторная работа №2

### Общая концепция

*   **Мультисписок (Multilist)** — это, как правило, структура данных, где элементы организованы в несколько списков одновременно (например, по разным критериям). Чаще всего реализуется через узлы с несколькими указателями.
*   **Очередь (Queue)** — FIFO (First-In, First-Out). Реализуется на основе массива или связного списка.
*   **Дек (Deque)** — Double-ended queue. Поддерживает добавление/удаление с обоих концов.
*   **Приоритетная очередь (Priority Queue)** — Элементы извлекаются не по порядку добавления, а по приоритету (чаще всего наибольший или наименьший элемент). "Под капотом" обычно используется **куча (Heap)**.

---

### С++ (Императивный, производительность, STL)

Ключевые черты: Использование STL, шаблоны, явное управление памятью (для собственных реализаций), высокая производительность.

1.  **Мультисписок**
    *   **Реализация:** В STL нет готового `multilist`. Реализуется вручную, обычно как двусвязный список (`std::list`) с дополнительными указателями или как специализированная структура (например, красно-черное дерево для `std::set` с несколькими компараторами — что уже не совсем список).
    *   **Пример:** `struct Node { int data; Node* next_list1; Node* prev_list1; Node* next_list2; Node* prev_list2; };`
    *   **Особенности:** Требует ручного управления памятью и указателями. Максимальный контроль, но и высокая сложность реализации.

2.  **Очередь**
    *   **Реализация:** `std::queue` — это адаптер контейнера. По умолчанию использует `std::deque`, но можно указать и `std::list`.
    *   **Пример:** `std::queue<int> q;`
    *   **Особенности:** Не является самостоятельным контейнером, а лишь предоставляет интерфейс поверх другого. Эффективность зависит от выбранного базового контейнера.

3.  **Дек**
    *   **Реализация:** `std::deque` — сложная внутренняя структура (часто "карта" указателей на блоки массивов). Позволяет эффективно добавлять/удалять элементы с обоих концов, а также имеет быстрый случайный доступ.
    *   **Пример:** `std::deque<int> dq;`
    *   **Особенности:** Гибридная структура, сочетающая преимущества вектора и списка. Обычно это основной выбор для реализации очереди и стека в C++.

4.  **Приоритетная очередь**
    *   **Реализация:** `std::priority_queue` — адаптер контейнера. По умолчанию использует `std::vector` и алгоритмы для работы с кучей (`std::make_heap`, `std::push_heap`, `std::pop_heap`).
    *   **Пример:** `std::priority_queue<int> pq;`
    *   **Особенности:** По умолчанию является **max-heap** (наибольший элемент наверху). Для min-heap нужно передать кастомный компаратор. Не поддерживает итерацию по всем элементам в отсортированном порядке.

---

### Java (Объектно-ориентированный, сборщик мусора, богатая стандартная библиотека)

Ключевые черты: Всё — объекты, сборщик мусора (GC), богатый `Collection Framework`, отсутствие явных указателей.

1.  **Мультисписок**
    *   **Реализация:** Нет прямой реализации. Создается вручную на основе узлов (`Node`), как и в C++, но без необходимости ручного управления памятью.
    *   **Пример:**
        ```java
        class MultiListNode<T> {
            T data;
            MultiListNode<T> nextA, prevA, nextB, prevB;
        }
        ```
    *   **Особенности:** GC избавляет от проблем с памятью. Код более безопасный, но менее эффективный из-за накладных расходов GC и отсутствия контроля над памятью.

2.  **Очередь**
    *   **Реализация:** Интерфейс `Queue`. Основные реализации: `LinkedList` (двусвязный список) и `ArrayDeque` (массив с изменяемым размером).
    *   **Пример:** `Queue<Integer> queue = new LinkedList<>();`
    *   **Особенности:** `ArrayDeque` обычно эффективнее `LinkedList` по памяти и производительности. Интерфейс `Queue` предоставляет два набора методов: `add(e)/remove()` (генерируют исключения) и `offer(e)/poll()` (возвращают специальное значение).

3.  **Дек**
    *   **Реализация:** Интерфейс `Deque`. Те же реализации: `LinkedList` и `ArrayDeque`.
    *   **Пример:** `Deque<Integer> deque = new ArrayDeque<>();`
    *   **Особенности:** `ArrayDeque` — рекомендуемая реализация для большинства случаев. Интерфейс очень богатый, предоставляет методы для работы с обоими концами.

4.  **Приоритетная очередь**
    *   **Реализация:** `PriorityQueue` — класс, основанный на **min-heap**. Использует динамический массив для хранения кучи.
    *   **Пример:** `PriorityQueue<Integer> pq = new PriorityQueue<>();`
    *   **Особенности:** **Min-heap** по умолчанию. Порядок можно изменить с помощью компаратора (`Comparator`). Как и в C++, не гарантирует порядок при итерации, только последовательное извлечение.

---

### Python (Динамическая типизация, лаконичность, "батарейки в комплекте")

Ключевые черты: Динамическая типизация, простой и лаконичный синтаксис, встроенные структуры данных, GIL.

1.  **Мультисписок**
    *   **Реализация:** Нет стандартной реализации. Легко моделируется с помощью вложенных списков, словарей или собственных классов.
    *   **Пример:** `multilist = {'list1': [], 'list2': []}` или класс, как в Java.
    *   **Особенности:** Максимальная простота и скорость написания кода, но потенциально меньшая производительность и контроль по сравнению с C++.

2.  **Очередь**
    *   **Реализация:** Модуль `queue` предоставляет потокобезопасные реализации. `Queue` (для многопоточности), `LifoQueue` (стек). Для обычных случаев часто используют `collections.deque`.
    *   **Пример (многопоточная):** `from queue import Queue; q = Queue()`
    *   **Особенности:** `queue.Queue` предназначена для синхронизации между потоками. Для однопоточных высокопроизводительных сценариев лучше `deque`.

3.  **Дек**
    *   **Реализация:** `collections.deque` — двухсторонняя очередь, реализованная на основе двусвязного списка из блоков (для эффективности).
    *   **Пример:** `from collections import deque; dq = deque()`
    *   **Особенности:** Потокобезопасна для операций `append`/`pop` с разных концов. Имеет методы `appendleft`, `popleft`. Очень эффективная и часто используемая структура.

4.  **Приоритетная очередь**
    *   **Реализация:** Модуль `heapq` предоставляет функции для работы с списком как с **min-heap**. Также есть `queue.PriorityQueue` (потокобезопасная версия на основе `heapq`).
    *   **Пример:**
        ```python
        import heapq
        heap = []
        heapq.heappush(heap, 5)
        min_val = heapq.heappop(heap)
        ```
    *   **Особенности:** Реализация на основе функций, работающих со стандартным списком. `heapq` создает min-heap. Для объектов обычно используют кортежи `(priority, data)`.

---

### Сводная таблица различий

| АТД | C++ | Java | Python |
| :--- | :--- | :--- | :--- |
| **Мультисписок** | Ручная реализация на указателях. Полный контроль, высокая сложность. | Ручная реализация на объектах. Безопасность благодаря GC. | Ручная реализация или использование встроенных структур (списки, словари). |
| **Очередь** | `std::queue` (адаптер, обычно на `deque`). | `Queue` (интерфейс), реализации `LinkedList`, `ArrayDeque`. | `queue.Queue` (потокобез.), `collections.deque` (эффективная). |
| **Дек** | `std::deque` (блочная структура, случайный доступ). | `Deque` (интерфейс), реализации `ArrayDeque`, `LinkedList`. | `collections.deque` (двусвязный список блоков, потокобез. операции). |
| **Приоритетная<br>очередь** | `std::priority_queue` (адаптер, обычно на `vector`, max-heap). | `PriorityQueue` (класс, min-heap). | `heapq` (функции для списка, min-heap), `queue.PriorityQueue` (потокобез.). |

