## Блочная сортировка (Bucket Sort) на языке Python

**Определение:**
Блочная сортировка (Bucket Sort) — это алгоритм, который распределяет элементы входного массива по нескольким "блокам" (корзинам), затем сортирует каждый блок отдельно (обычно с помощью другого алгоритма сортировки), и наконец объединяет отсортированные блоки в результирующий массив.

**Принцип работы:**
1. **Операторы поиска границ** `min(arr)` и `max(arr)` определяют минимальное и максимальное значения в массиве для вычисления диапазона распределения элементов
2. **Оператор создания блоков** `[[] for _ in range(bucket_count)]` инициализирует пустые блоки (корзины) для группировки элементов
3. **Оператор вычисления индекса** `int((num - min_val) / (max_val - min_val) * (bucket_count - 1))` определяет принадлежность каждого элемента к конкретному блоку на основе его значения
4. **Оператор распределения** `buckets[index].append(num)` помещает элементы в соответствующие блоки согласно вычисленному индексу
5. **Оператор сортировки** `sorted(bucket)` применяется к каждому блоку для упорядочивания элементов внутри него
6. **Оператор объединения** `result.extend()` собирает все отсортированные блоки в итоговый массив

**Особенности:**
Эффективна для равномерно распределенных данных и может достигать линейной сложности O(n) при оптимальном количестве блоков. Производительность сильно зависит от распределения данных - при неравномерном распределении эффективность снижается до O(n²).

**Почему O(n + k):** Распределение элементов по блокам с помощью **оператора вычисления индекса** и **оператора распределения** выполняется за O(n) времени. Сортировка блоков с использованием **оператора сортировки** в лучшем случае (равномерное распределение) требует O(n/k log(n/k)) операций для каждого из k блоков. Объединение результатов с помощью **оператора объединения** занимает O(k) времени. При оптимальном k = n и равномерном распределении данных общая сложность составляет O(n).


## Блинная сортировка (Pancake Sort) на языке Python

**Определение:**
Блинная сортировка (Pancake Sort) — это алгоритм, который сортирует массив, переворачивая его части (как будто переворачивая стопку блинов). На каждом шаге алгоритм находит максимальный элемент в неотсортированной части и переворачивает массив так, чтобы этот элемент оказался на своем правильном месте.

**Принцип работы:**
1. **Оператор поиска максимума** `max(arr[:curr_size])` находит наибольший элемент в текущей неотсортированной части массива
2. **Оператор определения индекса** `arr.index()` вычисляет позицию найденного максимального элемента
3. **Оператор частичного переворота** `arr[:max_idx + 1] = arr[:max_idx + 1][::-1]` переворачивает подмассив от начала до позиции максимального элемента, перемещая его в начало
4. **Оператор полного переворота** `arr[:curr_size] = arr[:curr_size][::-1]` переворачивает всю неотсортированную часть, устанавливая максимальный элемент на его окончательную позицию в конце
5. **Оператор уменьшения области** в цикле `for` последовательно сокращает размер обрабатываемой части массива, исключая уже отсортированные элементы

**Особенности:**
Сложность алгоритма — O(n²). Он интересен теоретически и используется как пример нестандартных методов сортировки, где единственная разрешенная операция — переворот префикса массива.

**Почему O(n²):** На каждой из n итераций **оператор поиска максимума** требует до O(n) сравнений, а **операторы переворота** выполняют до O(n) операций перемещения элементов. Поскольку алгоритм выполняет до 2n переворотов, каждый из которых требует O(n) операций, общее количество операций пропорционально n × n, что дает квадратичную сложность O(n²).

## Сортировка бусинами (Bead Sort) на языке C++

**Определение:**
Сортировка бусинами (Bead Sort) — это алгоритм, который имитирует падение бусин под действием гравитации. Каждое число представляется как столбец бусин, после чего бусины "падают" вниз, образуя отсортированную последовательность.

**Принцип работы:**
1. **Оператор поиска максимума** `std::max_element()` определяет максимальное значение в массиве для задания размеров матрицы бусин
2. **Оператор создания матрицы** `std::vector<bool>(max_val, false)` инициализирует двумерную сетку, где строки представляют значения элементов, а столбцы - позиции бусин
3. **Оператор размещения бусин** `beads[i][j] = true` устанавливает бусины в матрице согласно исходным значениям массива - каждое число отображается как последовательность бусин в столбце
4. **Оператор гравитационного падения** в циклах `for` перераспределяет бусины, перемещая их в нижние позиции столбцов с помощью операторов присваивания и подсчета
5. **Оператор подсчета** `sum++` определяет количество бусин в каждом столбце после "падения"
6. **Оператор считывания результатов** `while (j < max_val && beads[i][j])` преобразует окончательное расположение бусин обратно в числовые значения отсортированного массива

**Особенности:**
Алгоритм применим только для неотрицательных целых чисел. Визуально демонстрирует процесс сортировки как физическое явление. Практическая эффективность ограничена из-за необходимости создания крупной матрицы для хранения бусин.

**Почему O(n × m):** Сложность определяется размерами матрицы n × m, где n - количество элементов, m - максимальное значение. **Операторы установки, проверки и перераспределения бусин** выполняются для каждой ячейки матрицы, что составляет n × m операций. **Операторы подсчета и считывания** также обрабатывают все строки и столбцы матрицы. Поскольку общее количество операций пропорционально площади матрицы, временная сложность составляет O(n × m).


## Поиск скачками (Jump Search) на языке C++

**Определение:**
Поиск скачками (Jump Search) — это алгоритм поиска в отсортированном массиве, который работает путем прыжков фиксированного размера вперед, пока не найдет интервал, содержащий искомый элемент, после чего выполняет линейный поиск в этом интервале.

**Принцип работы:**
1. **Оператор вычисления шага** `int step = sqrt(n)` определяет оптимальный размер прыжка, равный квадратному корню из размера массива
2. **Оператор сравнения границ** `arr[std::min(step, n) - 1] < target` проверяет, не превысил ли текущий блок искомый элемент, определяя момент для перехода к линейному поиску
3. **Оператор экспоненциального перемещения** `step += sqrt(n)` увеличивает позицию для следующего прыжка, продвигаясь по массиву с постоянным шагом
4. **Оператор проверки границ** `if (prev >= n)` контролирует выход за пределы массива, предотвращая ошибки доступа к памяти
5. **Оператор линейного поиска** `while (arr[prev] < target)` выполняет последовательную проверку элементов в найденном блоке для точного определения позиции искомого элемента
6. **Оператор возврата результата** `return prev` возвращает индекс найденного элемента или -1 в случае его отсутствия

**Особенности:**
В среднем сложность поиска O(√n). Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное время. Эффективнее линейного поиска, но уступает бинарному в большинстве случаев.

**Почему O(√n):** Алгоритм выполняет не более **n/√n = √n** прыжков с помощью оператора сравнения границ, а затем выполняет линейный поиск в блоке размером √n с помощью оператора линейного поиска. Поскольку общее количество проверок составляет √n + √n = 2√n, что эквивалентно O(√n), алгоритм достигает сублинейной сложности.

## Анализ алгоритма: Экспоненциальный поиск (Exponential Search) на языке Java

**Определение:**
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.

**Принцип работы:**
1. **Оператор проверки первого элемента** `if (arr[0] == target)` проверяет начальный элемент массива.
2. Если элемент не найден, **оператор экспоненциального увеличения** `i = i * 2` увеличивает диапазон экспоненциально: 1, 2, 4, 8, 16 и т.д., пока **оператор условия цикла** `while (i < n && arr[i] <= target)` не найдет элемент, больше или равный искомому.
3. На найденном диапазоне выполняется бинарный поиск с использованием **оператора вычисления середины** `int mid = left + (right - left) / 2` и **операторов сравнения** `if (arr[mid] == target)`, `if (arr[mid] < target)` для определения направления поиска, а также **операторов обновления границ** `left = mid + 1`, `right = mid - 1` для сужения диапазона.

**Временная сложность: O(log n)**

**Почему O(log n):** Экспоненциальная фаза с **оператором увеличения индекса** `i = i * 2` выполняется за O(log n) времени, так как количество шагов до достижения границы массива логарифмически зависит от n. Бинарный поиск в диапазоне размером O(log n) с использованием **операторов сравнения и обновления границ** также требует O(log n) операций. Общая сложность O(log n) + O(log n) = O(log n).


## Анализ алгоритма: Экспоненциальный поиск (Exponential Search) на языке Java

**Определение:**
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.

**Принцип работы:**
1. **Оператор сравнения** `if (arr[0] == target)` проверяет первый элемент массива.
2. Если элемент не найден, **оператор цикла while** `while (i < n && arr[i] <= target)` с **оператором экспоненциального увеличения** `i = i * 2` увеличивает диапазон: 1, 2, 4, 8, 16 и т.д., пока не будет найден элемент, больше или равный искомому.
3. На найденном диапазоне выполняется бинарный поиск с использованием **оператора вычисления середины** `int mid = left + (right - left) / 2` и **операторов сравнения** `if (arr[mid] == target)`, `if (arr[mid] < target)` для определения положения элемента.

**Особенности:**
Сложность O(log n). Эффективен при поиске в очень больших отсортированных массивах с неизвестным размером или частичным доступом.

**Почему O(log n):** Экспоненциальная фаза с **оператором увеличения индекса** `i = i * 2` выполняется за O(log n) времени, так как количество шагов до достижения границы массива логарифмически зависит от n. Бинарный поиск в диапазоне размером O(log n) также требует O(log n) операций. Общая сложность составляет O(log n) + O(log n) = O(log n).
