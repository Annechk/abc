## Анализ алгоритма: Сортировка выбором (Selection Sort)
*   **Определение:**
    *   Сортировка выбором (Selection Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.
*   **Анализ:**
    *   Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.
    *   Внешний цикл `for` выполняется `n-1` раз.
    *   Внутренний цикл `for` в худшем случае выполняется `n-1`, затем `n-2`, ..., раз за каждый проход внешнего цикла.
    *   Общее количество сравнений примерно равно `n*(n-1)/2`.
*   **Временная сложность: O(n²)**
*   **Почему O(n²):** Два вложенных цикла, где каждый из них в среднем или худшем случае зависит от `n`. Внутренний цикл может выполняться до `n` раз для каждого из `n` итераций внешнего цикла, что приводит к квадратичной зависимости.


## Анализ алгоритма: Сортировка пузырьком (Bubble Sort)
*   **Определение:**
     *   Сортировка пузырьком (Bubble Sort) — это алгоритм, который многократно проходит по массиву, сравнивая и меняя местами соседние элементы, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.
*   **Анализ:**
    *   Алгоритм сравнивает соседние элементы массива и меняет их местами, если они находятся в неправильном порядке.
    *   Внешний цикл `for` выполняется до `n` раз.
    *   Внутренний цикл `for` в худшем случае выполняется `n-1`, затем `n-2`, ..., раз за каждый проход внешнего цикла.
    *   Общее количество сравнений примерно равно `n*(n-1)/2`.
*   **Временная сложность: O(n²)**
*   **Почему O(n²):** Два вложенных цикла, где каждый из них в среднем или худшем случае зависит от `n`. Внутренний цикл может выполняться до `n` раз для каждого из `n` итераций внешнего цикла, что приводит к квадратичной зависимости.


## Анализ алгоритма: Сортировка вставками (Insertion Sort)
*   **Определение:**
     *   Сортировка вставками (Insertion Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он берет первый элемент из неотсортированной части и вставляет его в правильную позицию в отсортированной части.
*   **Анализ:**
    *   Алгоритм берет элемент из неотсортированной части и вставляет его в правильную позицию в отсортированной части массива.
    *   Внешний цикл `for` выполняется `n-1` раз.
    *   Внутренний цикл `while` в худшем случае выполняется `i` раз для каждой итерации внешнего цикла, где `i` увеличивается от 1 до `n-1`.
    *   Общее количество сравнений примерно равно `n*(n-1)/4` в среднем случае.
*   **Временная сложность: O(n²)**
*   **Почему O(n²):** Два вложенных цикла, где каждый из них в среднем или худшем случае зависит от `n`. Внутренний цикл может выполняться до `n` раз для каждого из `n` итераций внешнего цикла, что приводит к квадратичной зависимости.


## Анализ алгоритма: Сортировка слиянием (Merge Sort)
*   **Определение:**
     *   Сортировка слиянием (Merge Sort) — это алгоритм, который использует стратегию "разделяй и властвуй". Он рекурсивно разделяет массив на две половины до тех пор, пока не останутся подмассивы из одного элемента, а затем сливает их в отсортированном порядке.
*   **Анализ:**
    *   Алгоритм рекурсивно разделяет массив на две половины до подмассивов из одного элемента, затем сливает их в отсортированном порядке.
    *   Рекурсивная функция `mergeSort` вызывается для каждой половины массива.
    *   Функция `merge` выполняет слияние двух отсортированных подмассивов, проходя по каждому элементу один раз.
    *   На каждом уровне рекурсии выполняется `O(n)` операций для слияния.
*   **Временная сложность: O(n log n)**
*   **Почему O(n log n):** Массив делится пополам на каждом уровне рекурсии, что дает `log n` уровней. На каждом уровне выполняется `O(n)` операций для слияния подмассивов, что в совокупности дает `O(n log n)`.


## Анализ алгоритма: Сортировка Шелла (Shell Sort)
*   **Определение:**
     *   Сортировка Шелла (Shell Sort) — это алгоритм, который является обобщением сортировки вставками. Он сортирует элементы, расположенные на определенном расстоянии друг от друга, постепенно уменьшая это расстояние до 1.
*   **Анализ:**
    *   Алгоритм сортирует элементы, находящиеся на расстоянии `gap` друг от друга, постепенно уменьшая это расстояние.
    *   Внешний цикл `while` выполняется `log n` раз (по количеству уменьшений промежутка).
    *   Внутренний цикл `for` выполняется `n - gap` раз для каждого значения `gap`.
    *   Внутренний цикл `while` в худшем случае может выполняться до `i/gap` раз для каждого элемента.
*   **Временная сложность: O(n²)**
*   **Почему O(n²):** В худшем случае, когда массив отсортирован в обратном порядке, алгоритм может деградировать до квадратичной сложности. Хотя последовательность промежутков может улучшить производительность, в наихудшем сценарии два вложенных цикла зависят от `n`, что приводит к квадратичной зависимости.


## Анализ алгоритма: Быстрая сортировка (Quick Sort)
*   **Определение:**
     *   Быстрая сортировка (Quick Sort) — это алгоритм, который использует стратегию "разделяй и властвуй". Он выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного, затем рекурсивно сортирует эти части.
*   **Анализ:**
    *   Алгоритм выбирает опорный элемент и разделяет массив на две части относительно этого элемента.
    *   Функция `partition` проходит по всем элементам от `low` до `high-1` и размещает элементы меньше опорного слева, а больше - справа.
    *   Рекурсивные вызовы `quickSort` выполняются для левой и правой частей массива.
    *   В среднем случае массив делится примерно пополам на каждом уровне рекурсии.
*   **Временная сложность: O(n log n)**
*   **Почему O(n log n):** В среднем случае массив делится пополам на каждом уровне рекурсии, что дает `log n` уровней. На каждом уровне выполняется `O(n)` операций для разделения, что в совокупности дает `O(n log n)`. В худшем случае (уже отсортированный массив) сложность может быть O(n²).


## Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
*   **Определение:**
     *   Пирамидальная сортировка (Heap Sort) — это алгоритм, который использует структуру данных "двоичная куча". Он строит max-кучу из массива, затем последовательно извлекает максимальный элемент и перестраивает кучу.
*   **Анализ:**
    *   Алгоритм строит max-кучу из массива, затем последовательно извлекает максимальный элемент и перестраивает кучу.
    *   Внешний цикл `for` выполняется `n-1` раз для извлечения элементов.
    *   Функция `heapify` в худшем случае выполняется `O(log n)` раз для каждого вызова.
    *   Построение начальной кучи выполняется за `O(n)` операций.
*   **Временная сложность: O(n log n)**
*   **Почему O(n log n):** Построение кучи занимает `O(n)` времени, а каждый из `n` вызовов `heapify` занимает `O(log n)` времени, что в совокупности дает `O(n log n)`.


## Анализ алгоритма: Последовательный (линейный) поиск (Linear Search)
*   **Определение:**
     *   Последовательный (линейный) поиск (Linear Search) — это алгоритм, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент или не проверит все элементы.
*   **Анализ:**
    *   Алгоритм последовательно проверяет каждый элемент массива, сравнивая его с целевым значением.
    *   Цикл `for` выполняется от 0 до `n-1` раз, где `n` - размер массива.
    *   В худшем случае алгоритм проверяет все `n` элементов массива.
    *   В лучшем случае алгоритм находит элемент на первой позиции.
    *   В среднем случае алгоритм проверяет примерно `n/2` элементов.
*   **Временная сложность: O(n)**
*   **Почему O(n):** В худшем случае алгоритм должен проверить все `n` элементов массива. Количество операций прямо пропорционально размеру массива `n`, что дает линейную зависимость.


## Анализ алгоритма: Бинарный поиск (Binary Search)
*   **Определение:**
     *   Бинарный поиск (Binary Search) — это алгоритм, который работает на отсортированном массиве. На каждом шаге он сравнивает искомый элемент со средним элементом массива и в зависимости от результата продолжает поиск в левой или правой половине.
*   **Анализ:**
    *   Алгоритм сравнивает искомый элемент со средним элементом массива и в зависимости от результата продолжает поиск в левой или правой половине.
    *   Цикл `while` выполняется до тех пор, пока левая граница не станет больше правой.
    *   На каждой итерации размер области поиска уменьшается вдвое.
    *   Количество итераций равно количеству раз, которое массив можно разделить пополам.
*   **Временная сложность: O(log n)**
*   **Почему O(log n):** На каждой итерации алгоритм уменьшает область поиска в два раза. Максимальное количество итераций, необходимое для поиска элемента, равно log₂n, что дает логарифмическую зависимость.


## Анализ алгоритма: Интерполирующий поиск (Interpolation Search)
*   **Определение:**
     *   Интерполирующий поиск (Interpolation Search) — это алгоритм, который работает на отсортированном массиве с равномерно распределенными значениями. Он вычисляет вероятную позицию искомого элемента с помощью интерполяционной формулы.
*   **Анализ:**
    *   Алгоритм вычисляет вероятную позицию искомого элемента с помощью интерполяционной формулы и сравнивает элемент в этой позиции с целевым значением.
    *   Цикл `while` выполняется до тех пор, пока границы не пересекутся или целевой элемент не выйдет за пределы диапазона.
    *   На каждой итерации область поиска уменьшается в зависимости от значения искомого элемента.
    *   Количество итераций зависит от распределения данных в массиве.
*   **Временная сложность: O(log log n)**
*   **Почему O(log log n):** В среднем случае, при равномерном распределении данных, алгоритм уменьшает область поиска экспоненциально быстрее, чем бинарный поиск, что дает двойную логарифмическую зависимость. В худшем случае сложность может быть O(n).

## Анализ алгоритма: Поиск Фибоначчи (Fibonacci Search)
*   **Определение:**
     *   Поиск Фибоначчи (Fibonacci Search) — это алгоритм, который работает на отсортированном массиве и использует числа Фибоначчи для определения позиции разделения массива. Он делит массив на части, пропорциональные числам Фибоначчи.
*   **Анализ:**
    *   Алгоритм использует числа Фибоначчи для определения позиции разделения массива и сравнивает элемент в этой позиции с целевым значением.
    *   Первый цикл `while` находит наименьшее число Фибоначчи, большее или равное размеру массива.
    *   Второй цикл `while` выполняет поиск, уменьшая числа Фибоначчи на каждой итерации.
    *   Количество итераций зависит от размера массива и чисел Фибоначчи.
*   **Временная сложность: O(log n)**
*   **Почему O(log n):** Алгоритм уменьшает размер области поиска примерно на коэффициент золотого сечения (φ ≈ 1.618) на каждой итерации, что дает логарифмическую зависимость от размера массива n.
